# c++性能优化
## 目录
## [1.使用const关键字](#1)
## [2.使用inline关键字](#2)
## [3.使用引用传递代替值传递](#3)
## [4.使用迭代器可能比使用指针更优](#4)
## [5.减少函数调用的开销](#5)
## [6.低级代码使用位运算替代算术运算](#6)
## [7.使用编译器自带的优化选项](#7)
## [8.内存管理](#8)
## [9.多线程并发](#9)
---
<h3 id="1">1.使用const关键字</h3>

### const是一个修饰符，可以告诉编译器这是个常量，这样可以提高程序的性能，以及避免一些常见的错误。
```
const int N = 10;
```
---
<h3 id="2">2.使用inline关键字</h3>

### inline可以用来提示编译器尝试将函数“内联化”。如果一个函数被内联，那么每次调用这个函数的地方，编译器都会用函数体来替换调用语句，而不是跳转到函数所在的内存位置进行调用，减少函数调用的开销。
```
inline int add(int a, int b) {
    return a + b;
}
```
---
<h3 id="3">3.使用引用传递代替值传递</h3>

### 使用引用传递代替值传递会减少拷贝的数量，从而降低开销。(特别是在大数据类的时候)
---
<h3 id="4">4.使用迭代器可能比使用指针更优</h3>

### 在遍历一个STL容器的时候，使用迭代器会优于用for循环的方式取值，减少程序控制循环的开销。
```
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // 使用迭代器遍历 vector
    for (std::vector<int>::iterator it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << std::endl;
    }

    return 0;
}
```
---
<h3 id="5">5.减少函数调用的开销</h3>

### 减少函数调用次数可以提升程序的性能。函数调用本身是有开销的，特别是当函数被频繁调用时，这个开销可能会显著影响程序的性能。
---
<h3 id="6">6.低级代码使用位运算替代算术运算</h3>

### 位运算符确实比算术运算符在执行速度上更快，因为位运算符直接对二进制位进行操作，而算术运算符需要进行更复杂的计算。
---
<h3 id="7">7.使用编译器自带的优化选项</h3>

### 现代编译器通常提供了许多优化选项，可以用来提高生成的代码的性能。这些优化包括函数内联、循环展开、死代码消除、常量折叠、指令重排等。
- O1：这个选项会启用一些基本的优化，比如移除未使用的代码和变量，简化算术运算等。这个选项提供了一个很好的编译时间和运行时间的平衡。
- O2：这个选项启用了更多的优化，比如代码重排和指令级并行化。这些优化可以使代码运行得更快，但也会使编译时间更长。
- Os：这个选项启用了所有不会增加代码大小的优化。这个选项对于需要控制代码大小的系统，比如嵌入式系统，非常有用。
- Ofast：这个选项启用了所有的优化，并且允许编译器违反一些数学准则，如忽略浮点数的NaN和Inf值。这个选项可以使代码运行得最快，但可能会导致数值计算的结果不准确。
- march=native：这个选项让编译器生成针对当前机器的优化代码。这可以提升性能，但生成的代码可能无法在不同的机器上运行。
---
<h3 id="8">8.内存管理</h3>

- ### 1.使用智能指针来创建类对象，自动释放内存。
```
void example() {
    std::unique_ptr<int> num = std::make_unique<int>(42);
    // num 会在作用域结束时自动释放
}

```
- ### 2.内存池预分配
```
constexpr int N = 1e8;
#if 0
void test() {
    int *cache = new int;
    for (int i = 0; i < 100000000; ++i) {
        int *ptr = cache;
        *ptr = i;
    }
    delete cache;
}
#else

void test() {
    for (int i = 0; i < 100000000; ++i) {
        int* ptr = new int;
        *ptr = i;
        delete ptr;
    }
}
#endif
```
- ### 3.内存对齐,CPU 更擅长访问对齐的数据，所以尽量让结构体的字段按对齐规则排列。
```
struct AlignedStruct {
    int a;    // 4 字节
    double b; // 8 字节
    char c;   // 1 字节，但会补齐到 8 字节
};

```
## 结构体对齐规则:
1. ### 结构体变量的首地址是最长成员长度的整数倍
2. ### 每个成员相对于结构体首地址的偏移量，一定是该成员长度的整数倍
3. ### 结构体的总长度是最长成员长度的整数倍
4. ### 如果结构体内有成员长度大于处理器的位数，那么就以处理器的位数作为对齐单位
---
<h3 id="9">9.多线程并发</h3>

### 锁是用来同步多线程访问共享资源的，但锁多了会导致性能下降。如果能用 std::atomic，尽量别用 std::mutex，原子操作更高效。
```
std::atomic<int> counter = 0;

void increment() {
    counter++;
}

```
### 合理划分任务:多线程编程不是线程越多越快，任务划分得不好，线程调度的开销会大于性能提升。一个简单的规则是：线程数 ≈ CPU 核心数。
---
